/**
 * BSD-style license; for more info see http://pmd.sourceforge.net/license.html
 */
/* Generated By:JJTree: Do not edit this line. Node.java */

package net.sourceforge.pmd.lang.ast;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.jaxen.BaseXPath;
import org.jaxen.JaxenException;
import org.w3c.dom.Document;

import net.sourceforge.pmd.lang.ast.xpath.Attribute;
import net.sourceforge.pmd.lang.ast.xpath.AttributeAxisIterator;
import net.sourceforge.pmd.lang.ast.xpath.DocumentNavigator;
import net.sourceforge.pmd.lang.dfa.DataFlowNode;

/**
 * All AST nodes must implement this interface. It provides basic machinery for constructing the parent and child
 * relationships between nodes.
 */
public interface Node {

    // COMMENT: is it ok to take the opportunity on PMD 7 to rename this API and take out of there the methods
    // that are only needed for javaCC implementations?

    /**
     * This method is called after the node has been made the current node. It indicates that child nodes can now be
     * added to it.
     */
    void jjtOpen();

    /**
     * This method is called after all the child nodes have been added.
     */
    void jjtClose();

    /**
     * Sets the parent of this node.
     *
     * @param parent The parent
     */
    void jjtSetParent(Node parent);

    /**
     * Returns the parent of this node.
     *
     * @return The parent of the node
     */
    Node jjtGetParent();

    /**
     * This method tells the node to add its argument to the node's list of children.
     *
     * @param child The child to add
     * @param index The index to which the child will be added
     */
    void jjtAddChild(Node child, int index);

    /**
     * Sets the index of this node from the perspective of its parent. This means: this.jjtGetParent().jjtGetChild(index)
     * == this.
     *
     * @param index the child index
     */
    void jjtSetChildIndex(int index);

    /**
     * Gets the index of this node in the children of its parent.
     *
     * @return The index of the node
     */
    int jjtGetChildIndex();

    /**
     * This method returns a child node. The children are numbered from zero, left to right.
     *
     * @param index the child index. Must be nonnegative and less than {@link #jjtGetNumChildren}.
     */
    Node jjtGetChild(int index);

    /**
     * Returns the number of children the node has.
     */
    int jjtGetNumChildren();

    int jjtGetId();

    /**
     * Returns a string token, usually filled-in by the parser, which describes some textual characteristic of this
     * node. This is usually an identifier, but you should check that using the Designer. On most nodes though, this
     * method returns {@code null}.
     */
    String getImage();

    void setImage(String image);

    /**
     * Returns true if this node's image is equal to the given string.
     *
     * @param image The image to check
     */
    boolean hasImageEqualTo(String image);

    int getBeginLine();

    int getBeginColumn();

    int getEndLine();

    int getEndColumn();

    DataFlowNode getDataFlowNode();

    void setDataFlowNode(DataFlowNode dataFlowNode);

    /**
     * Returns true if this node is considered a boundary by traversal methods. Traversal methods such as {@link
     * #getFirstDescendantOfType(Class)} don't look past such boundaries by default, which is usually the expected thing
     * to do. For example, in Java, lambdas and nested classes are considered find boundaries.
     */
    default boolean isFindBoundary() {
        return false;
    }

    /**
     * Returns the n-th parent or null if there are less than {@code n} ancestors.
     *
     * @param n how many ancestors to iterate over.
     * @return the n-th parent or null.
     * @throws IllegalArgumentException if {@code n} is negative or zero.
     */
    default Node getNthParent(int n) {
        if (n <= 0) {
            throw new IllegalArgumentException();
        }
        Node result = this.jjtGetParent();
        for (int i = 1; i < n; i++) {
            if (result == null) {
                return null;
            }
            result = result.jjtGetParent();
        }
        return result;
    }

    /**
     * Traverses up the tree to find the first parent instance of type parentType or one of its subclasses.
     *
     * @param parentType Class literal of the type you want to find
     * @param <T> The type you want to find
     * @return Node of type parentType. Returns null if none found.
     */
    default <T> T getFirstParentOfType(Class<T> parentType) {
        Node parentNode = jjtGetParent();
        while (parentNode != null && !parentType.isInstance(parentNode)) {
            parentNode = parentNode.jjtGetParent();
        }
        return parentType.cast(parentNode);
    }

    /**
     * Traverses up the tree to find all of the parent instances of type parentType or one of its subclasses. The nodes
     * are ordered deepest-first.
     *
     * @param parentType Class literal of the type you want to find
     * @param <T> The type you want to find
     * @return List of parentType instances found.
     */
    default <T> List<T> getParentsOfType(Class<T> parentType) {
        final List<T> parents = new ArrayList<>();
        Node parentNode = jjtGetParent();
        while (parentNode != null) {
            if (parentType.isInstance(parentNode)) {
                parents.add(parentType.cast(parentNode));
            }
            parentNode = parentNode.jjtGetParent();
        }
        return parents;
    }

    /**
     * Gets the first parent that's an instance of any of the given types.
     *
     * @param parentTypes Types to look for
     * @param <T> Most specific common type of the parameters
     * @return The first parent with a matching type. Returns null if there is no such parent
     */
    default <T> T getFirstParentOfAnyType(Class<? extends T>... parentTypes) {
        Node parentNode = jjtGetParent();
        while (parentNode != null) {
            for (final Class<? extends T> c : parentTypes) {
                if (c.isInstance(parentNode)) {
                    return c.cast(parentNode);
                }
            }
            parentNode = parentNode.jjtGetParent();
        }
        return null;
    }

    /**
     * Traverses the children to find all the instances of type childType or one of its subclasses.
     *
     * @param childType class which you want to find.
     * @return List of all children of type childType. Returns an empty list if none found.
     * @see #findDescendantsOfType(Class) if traversal of the entire tree is needed.
     */
    default <T> List<T> findChildrenOfType(Class<T> childType) {
        final List<T> list = new ArrayList<>();
        for (int i = 0; i < jjtGetNumChildren(); i++) {
            final Node child = jjtGetChild(i);
            if (childType.isInstance(child)) {
                list.add(childType.cast(child));
            }
        }
        return list;
    }

    /**
     * Traverses down the tree to find all the descendant instances of type descendantType without crossing find
     * boundaries.
     *
     * @param targetType class which you want to find.
     * @return List of all children of type targetType. Returns an empty list if none found.
     */
    default <T> List<T> findDescendantsOfType(Class<T> targetType) {
        final List<T> list = new ArrayList<>();
        TraversalUtils.findDescendantsOfType(this, targetType, list, false);
        return list;
    }

    /**
     * Traverses down the tree to find all the descendant instances of type targetType
     *
     * @param targetType class which you want to find.
     * @param crossBoundaries if <code>false</code>, recursion stops for nodes for which {@link #isFindBoundary()} is
     * <code>true</code>
     * @return List of all children of type targetType. Returns an empty list if none found.
     */
    default <T> List<T> findDescendantsOfType(Class<T> targetType, boolean crossBoundaries) {
        final List<T> list = new ArrayList<>();
        TraversalUtils.findDescendantsOfType(this, targetType, list, crossBoundaries);
        return list;
    }

    /**
     * Traverses down the tree to find all the descendant instances of type descendantType.
     *
     * @param targetType class which you want to find.
     * @param results list to store the matching descendants
     * @param crossFindBoundaries if <code>false</code>, recursion stops for nodes for which {@link #isFindBoundary()}
     * is <code>true</code>
     */
    default <T> void findDescendantsOfType(Class<T> targetType, List<T> results, boolean crossFindBoundaries) {
        TraversalUtils.findDescendantsOfType(this, targetType, results, crossFindBoundaries);
    }

    /**
     * Traverses the children to find the first instance of type childType.
     *
     * @param childType class which you want to find.
     * @return Node of type childType. Returns <code>null</code> if none found.
     * @see #getFirstDescendantOfType(Class) if traversal of the entire tree is needed.
     */
    default <T> T getFirstChildOfType(Class<T> childType) {
        int n = jjtGetNumChildren();
        for (int i = 0; i < n; i++) {
            final Node child = jjtGetChild(i);
            if (childType.isInstance(child)) {
                return childType.cast(child);
            }
        }
        return null;
    }

    /**
     * Traverses down the tree to find the first descendant instance of type descendantType without crossing find
     * boundaries.
     *
     * @param descendantType class which you want to find.
     * @return Node of type descendantType. Returns <code>null</code> if none found.
     */
    default <T> T getFirstDescendantOfType(Class<T> descendantType) {
        return TraversalUtils.getFirstDescendantOfType(descendantType, this);
    }

    /**
     * Finds if this node contains a descendant of the given type without crossing find boundaries.
     *
     * @param type the node type to search
     * @return <code>true</code> if there is at least one descendant of the given type
     */
    default <T> boolean hasDescendantOfType(Class<T> type) {
        return getFirstDescendantOfType(type) != null;
    }

    /**
     * Returns all the nodes matching the xpath expression.
     *
     * @param xpathString the expression to check
     * @return List of all matching nodes. Returns an empty list if none found.
     * @throws JaxenException if the xpath is incorrect or fails altogether
     */
    @SuppressWarnings("unchecked")
    default List<Node> findChildNodesWithXPath(String xpathString) throws JaxenException {
        return new BaseXPath(xpathString, new DocumentNavigator()).selectNodes(this);
    }

    /**
     * Checks whether at least one descendant matches the xpath expression.
     *
     * @param xpathString the expression to check
     * @return true if there is a match
     */
    default boolean hasDescendantMatchingXPath(String xpathString) {
        try {
            return !findChildNodesWithXPath(xpathString).isEmpty();
        } catch (final JaxenException e) {
            throw new RuntimeException("XPath expression " + xpathString + " failed: " + e.getLocalizedMessage(), e);
        }
    }

    /**
     * Get a DOM Document which contains Elements and Attributes representative of this Node and it's children.
     * Essentially a DOM tree representation of the Node AST, thereby allowing tools which can operate upon DOM to also
     * indirectly operate on the AST.
     */
    default Document getAsDocument() {
        try {
            final DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
            final DocumentBuilder db = dbf.newDocumentBuilder();
            final Document document = db.newDocument();
            DocumentUtils.appendElement(this, document);
            return document;
        } catch (final ParserConfigurationException pce) {
            throw new RuntimeException(pce);
        }
    }

    /**
     * Get the user data associated with this node. By default there is no data, unless it has been set via {@link
     * #setUserData(Object)}.
     *
     * @return The user data set on this node.
     */
    Object getUserData();

    /**
     * Set the user data associated with this node.
     * <p>
     * <p>PMD itself will never set user data onto a node. Nor should any Rule
     * implementation, as the AST nodes are shared between concurrently executing Rules (i.e. it is <strong>not</strong>
     * thread-safe).
     * <p>
     * <p>This API is most useful for external applications looking to leverage
     * PMD's robust support for AST structures, in which case application specific annotations on the AST nodes can be
     * quite useful.
     *
     * @param userData The data to set on this node.
     */
    void setUserData(Object userData);

    /**
     * Remove the current node from its parent.
     */
    void remove();

    /**
     * This method tells the node to remove the child node at the given index from the node's list of children, if any;
     * if not, no changes are done.
     *
     * @param childIndex The index of the child to be removed
     */
    void removeChildAtIndex(int childIndex);

    /**
     * Gets the name of the node that is used to match it with XPath queries.
     *
     * @return The XPath node name
     */
    String getXPathNodeName();

    /**
     * Returns an iterator enumerating all the attributes that are available from XPath for this node.
     *
     * @return An attribute iterator for this node
     */
    default Iterator<Attribute> getXPathAttributesIterator() {
        return new AttributeAxisIterator(this);
    }
}
